# Ensei Platform - Cursor Rules

## Core Principles

### 1. Industry Standards & Best Practices
- **Always implement industry-standard patterns** for any task or feature
- Follow **SOLID principles** and **clean architecture** patterns
- Use **TypeScript strict mode** with proper type definitions
- Implement **proper error handling** with try-catch blocks and user-friendly messages
- Follow **React best practices**: hooks, functional components, proper state management
- Use **semantic HTML** and **accessibility standards** (WCAG 2.1 AA)
- Implement **responsive design** with mobile-first approach
- Follow **RESTful API design** principles for backend endpoints

### 2. Scalability Requirements
- **Design for large-scale usage** (10,000+ concurrent users)
- Use **database indexing** and **query optimization**
- Implement **caching strategies** (Redis, CDN, browser caching)
- Use **pagination** for large data sets
- Implement **rate limiting** and **DDoS protection**
- Use **connection pooling** for database connections
- Implement **horizontal scaling** patterns
- Use **microservices architecture** where appropriate
- Implement **async processing** for heavy operations
- Use **queue systems** for background tasks

### 3. Data Management & Storage
- **NEVER depend on localStorage** for critical application state
- Use **server-side state management** for user data, authentication, and business logic
- Implement **proper session management** with secure tokens
- Use **database transactions** for data consistency
- Implement **data validation** on both client and server sides
- Use **environment variables** for configuration
- Implement **proper backup and recovery** strategies
- Use **encrypted storage** for sensitive data

### 4. Authentication & Security
- Use **JWT tokens** with proper expiration and refresh mechanisms
- Implement **OAuth 2.0** for third-party integrations
- Use **HTTPS everywhere** with proper SSL certificates
- Implement **CORS** properly for cross-origin requests
- Use **input sanitization** and **XSS protection**
- Implement **CSRF protection**
- Use **secure headers** (HSTS, CSP, etc.)
- Implement **proper password hashing** (bcrypt, Argon2)

### 5. Performance Optimization
- Implement **lazy loading** for components and routes
- Use **code splitting** and **tree shaking**
- Optimize **bundle size** and **loading times**
- Implement **image optimization** and **lazy loading**
- Use **CDN** for static assets
- Implement **service workers** for offline functionality
- Use **memoization** for expensive calculations
- Implement **virtual scrolling** for large lists

### 6. Testing & Quality Assurance
- Write **unit tests** for all business logic
- Implement **integration tests** for API endpoints
- Use **end-to-end tests** for critical user flows
- Implement **error monitoring** and **logging**
- Use **code coverage** tools (minimum 80% coverage)
- Implement **automated testing** in CI/CD pipeline
- Use **static analysis** tools (ESLint, Prettier, TypeScript)
- Implement **performance monitoring**

### 7. Database Design
- Use **normalized database schema** with proper relationships
- Implement **database migrations** for schema changes
- Use **indexes** for frequently queried fields
- Implement **soft deletes** instead of hard deletes
- Use **database constraints** for data integrity
- Implement **audit trails** for important data changes
- Use **connection pooling** and **query optimization**
- Implement **database backup** and **recovery procedures**

### 8. API Design
- Use **RESTful conventions** with proper HTTP methods
- Implement **proper status codes** and error responses
- Use **API versioning** for backward compatibility
- Implement **rate limiting** and **throttling**
- Use **API documentation** (OpenAPI/Swagger)
- Implement **request/response validation**
- Use **proper error handling** with meaningful messages
- Implement **API monitoring** and **analytics**

### 9. Frontend Architecture
- Use **component-based architecture** with reusable components
- Implement **proper state management** (Redux, Zustand, or Context API)
- Use **custom hooks** for business logic
- Implement **error boundaries** for error handling
- Use **proper routing** with lazy loading
- Implement **SEO optimization** with meta tags
- Use **progressive web app** features where appropriate
- Implement **accessibility** features (ARIA labels, keyboard navigation)

### 10. Deployment & DevOps
- Use **containerization** (Docker) for consistent deployments
- Implement **CI/CD pipelines** with automated testing
- Use **infrastructure as code** (Terraform, CloudFormation)
- Implement **monitoring** and **alerting** systems
- Use **log aggregation** and **analysis** tools
- Implement **blue-green deployments** for zero downtime
- Use **environment-specific configurations**
- Implement **disaster recovery** procedures

## Implementation Guidelines

### When implementing any feature:
1. **Start with requirements analysis** and technical design
2. **Create proper TypeScript interfaces** and types
3. **Implement error handling** from the beginning
4. **Write tests** alongside the implementation
5. **Consider scalability** implications
6. **Use proper data validation** and sanitization
7. **Implement proper logging** and monitoring
8. **Document the implementation** with comments
9. **Consider security implications** of the feature
10. **Test with realistic data volumes**

### Code Quality Standards:
- **Maximum function length**: 50 lines
- **Maximum file length**: 300 lines
- **Maximum cyclomatic complexity**: 10
- **Use meaningful variable and function names**
- **Write self-documenting code** with clear intent
- **Use consistent formatting** and style
- **Remove unused code** and dependencies
- **Use proper imports** and exports

### Security Checklist:
- [ ] Input validation implemented
- [ ] Output encoding applied
- [ ] Authentication required where needed
- [ ] Authorization checks in place
- [ ] Sensitive data encrypted
- [ ] Error messages don't leak information
- [ ] Logging doesn't expose sensitive data
- [ ] HTTPS enforced
- [ ] CORS configured properly
- [ ] Rate limiting implemented

### Performance Checklist:
- [ ] Database queries optimized
- [ ] Caching implemented where appropriate
- [ ] Images optimized and lazy loaded
- [ ] Code splitting implemented
- [ ] Bundle size analyzed
- [ ] Loading states implemented
- [ ] Error boundaries in place
- [ ] Memory leaks prevented
- [ ] API response times acceptable
- [ ] CDN configured for static assets

## Prohibited Practices

### NEVER do these:
- Store critical application state in localStorage
- Use synchronous operations for I/O
- Hardcode sensitive information
- Skip input validation
- Ignore error handling
- Use deprecated or insecure libraries
- Implement features without proper testing
- Skip performance considerations
- Ignore accessibility requirements
- Deploy without proper monitoring

## Technology Stack Standards

### Frontend:
- **React 18+** with TypeScript
- **Next.js 14+** for SSR/SSG
- **Tailwind CSS** for styling
- **React Query** for server state management
- **React Hook Form** for form handling
- **Zod** for validation
- **Jest** and **React Testing Library** for testing

### Backend:
- **Node.js** with TypeScript
- **Express.js** or **Fastify** for API
- **Firebase** for authentication and database
- **Redis** for caching
- **JWT** for token management
- **Bcrypt** for password hashing
- **Jest** for testing

### Infrastructure:
- **Vercel** for frontend deployment
- **Firebase Functions** for serverless backend
- **Cloudflare** for CDN and security
- **GitHub Actions** for CI/CD
- **Sentry** for error monitoring
- **Vercel Analytics** for performance monitoring

Remember: **Quality over speed**. Always implement features with industry standards, proper testing, and scalability in mind.

## üèóÔ∏è **FEATURE-FIRST ARCHITECTURE PRINCIPLES**

### **CRITICAL RULE: Group code by FEATURE, not by type**
- **NEVER** create or expand global buckets like `src/components`, `src/utils`, `src/services` unless the code is truly cross-feature
- **ALWAYS** place new code under feature-specific folders
- **EVERY** feature must be self-contained with its own components, hooks, API calls, state, and schemas
- **AVOID** sprinkling code into type-based buckets
- **BUILD** cohesive feature modules that can be easily maintained and tested

### **Feature Placement Rules:**
1. **WEB APP**: Place new code under `src/features/<feature>/{components,hooks,api,state,schemas}`
2. **API GATEWAY**: Create `src/modules/<module>/{http,app,infra}` with hexagonal boundaries
3. **Pages/screens** must import only from `src/features/*` and `src/shared/*`
4. **Domain/app logic** must not import framework/SDKs directly; only via infra adapters
5. **Feature variations** (e.g., ClaimDropdown) go in the same feature folder
6. **Tests** are co-located next to code (`*.test.ts[x]`) inside its feature/module
7. **Shared types/schemas** come from `packages/shared-types`; do not duplicate
8. **When unsure**: create a new feature/module rather than putting code in shared

### **One-Sentence Rule for Cursor:**
"Place all new code in feature folders (src/features/<feature> for web, src/modules/<module> for API), expose via index.ts, and never add logic to global buckets."

### **System Design Requirements:**
1. **Unified Data Flow**: All related operations must use the same data sources and state management
2. **Consistent Architecture**: Follow the same patterns across all features
3. **Proper Error Handling**: Every system must have comprehensive error boundaries
4. **Real-time Updates**: All systems must support live data synchronization
5. **Type Safety**: Full TypeScript coverage with proper interfaces
6. **Testing**: Every system must be testable and tested
7. **Documentation**: Clear system documentation and API contracts

### **Anti-Patterns to Avoid:**
- ‚ùå Creating separate code paths for similar operations
- ‚ùå Patching existing systems instead of redesigning them
- ‚ùå Using different data sources for related features
- ‚ùå Implementing quick fixes without considering the bigger picture
- ‚ùå Building features in isolation without system integration
- ‚ùå Placing feature logic in global buckets
- ‚ùå Creating type-based folder structures instead of feature-based ones

### **System Integration Checklist:**
- [ ] Does this feature integrate with existing systems?
- [ ] Are we using consistent data sources and state management?
- [ ] Does this follow the same architectural patterns?
- [ ] Is error handling consistent across the system?
- [ ] Are real-time updates working properly?
- [ ] Is the code maintainable and scalable?
- [ ] Is the code placed in the correct feature folder?
- [ ] Are imports only from feature boundaries and shared modules?