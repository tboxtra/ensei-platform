# Ensei Platform - Cursor Rules

## Core Principles

### 1. Industry Standards & Best Practices
- **Always implement industry-standard patterns** for any task or feature
- Follow **SOLID principles** and **clean architecture** patterns
- Use **TypeScript strict mode** with proper type definitions
- Implement **proper error handling** with try-catch blocks and user-friendly messages
- Follow **React best practices**: hooks, functional components, proper state management
- Use **semantic HTML** and **accessibility standards** (WCAG 2.1 AA)
- Implement **responsive design** with mobile-first approach
- Follow **RESTful API design** principles for backend endpoints

### 2. Scalability Requirements
- **Design for large-scale usage** (10,000+ concurrent users)
- Use **database indexing** and **query optimization**
- Implement **caching strategies** (Redis, CDN, browser caching)
- Use **pagination** for large data sets
- Implement **rate limiting** and **DDoS protection**
- Use **connection pooling** for database connections
- Implement **horizontal scaling** patterns
- Use **microservices architecture** where appropriate
- Implement **async processing** for heavy operations
- Use **queue systems** for background tasks

### 3. Data Management & Storage
- **NEVER depend on localStorage** for critical application state
- Use **server-side state management** for user data, authentication, and business logic
- Implement **proper session management** with secure tokens
- Use **database transactions** for data consistency
- Implement **data validation** on both client and server sides
- Use **environment variables** for configuration
- Implement **proper backup and recovery** strategies
- Use **encrypted storage** for sensitive data

### 4. Authentication & Security
- Use **JWT tokens** with proper expiration and refresh mechanisms
- Implement **OAuth 2.0** for third-party integrations
- Use **HTTPS everywhere** with proper SSL certificates
- Implement **CORS** properly for cross-origin requests
- Use **input sanitization** and **XSS protection**
- Implement **CSRF protection**
- Use **secure headers** (HSTS, CSP, etc.)
- Implement **proper password hashing** (bcrypt, Argon2)

### 5. Performance Optimization
- Implement **lazy loading** for components and routes
- Use **code splitting** and **tree shaking**
- Optimize **bundle size** and **loading times**
- Implement **image optimization** and **lazy loading**
- Use **CDN** for static assets
- Implement **service workers** for offline functionality
- Use **memoization** for expensive calculations
- Implement **virtual scrolling** for large lists

### 6. Testing & Quality Assurance
- Write **unit tests** for all business logic
- Implement **integration tests** for API endpoints
- Use **end-to-end tests** for critical user flows
- Implement **error monitoring** and **logging**
- Use **code coverage** tools (minimum 80% coverage)
- Implement **automated testing** in CI/CD pipeline
- Use **static analysis** tools (ESLint, Prettier, TypeScript)
- Implement **performance monitoring**

### 7. Database Design
- Use **normalized database schema** with proper relationships
- Implement **database migrations** for schema changes
- Use **indexes** for frequently queried fields
- Implement **soft deletes** instead of hard deletes
- Use **database constraints** for data integrity
- Implement **audit trails** for important data changes
- Use **connection pooling** and **query optimization**
- Implement **database backup** and **recovery procedures**

### 8. API Design
- Use **RESTful conventions** with proper HTTP methods
- Implement **proper status codes** and error responses
- Use **API versioning** for backward compatibility
- Implement **rate limiting** and **throttling**
- Use **API documentation** (OpenAPI/Swagger)
- Implement **request/response validation**
- Use **proper error handling** with meaningful messages
- Implement **API monitoring** and **analytics**

### 9. Frontend Architecture
- Use **component-based architecture** with reusable components
- Implement **proper state management** (Redux, Zustand, or Context API)
- Use **custom hooks** for business logic
- Implement **error boundaries** for error handling
- Use **proper routing** with lazy loading
- Implement **SEO optimization** with meta tags
- Use **progressive web app** features where appropriate
- Implement **accessibility** features (ARIA labels, keyboard navigation)

### 10. Deployment & DevOps
- Use **containerization** (Docker) for consistent deployments
- Implement **CI/CD pipelines** with automated testing
- Use **infrastructure as code** (Terraform, CloudFormation)
- Implement **monitoring** and **alerting** systems
- Use **log aggregation** and **analysis** tools
- Implement **blue-green deployments** for zero downtime
- Use **environment-specific configurations**
- Implement **disaster recovery** procedures

## Implementation Guidelines

### When implementing any feature:
1. **Start with requirements analysis** and technical design
2. **Create proper TypeScript interfaces** and types
3. **Implement error handling** from the beginning
4. **Write tests** alongside the implementation
5. **Consider scalability** implications
6. **Use proper data validation** and sanitization
7. **Implement proper logging** and monitoring
8. **Document the implementation** with comments
9. **Consider security implications** of the feature
10. **Test with realistic data volumes**

### Code Quality Standards:
- **Maximum function length**: 50 lines
- **Maximum file length**: 300 lines
- **Maximum cyclomatic complexity**: 10
- **Use meaningful variable and function names**
- **Write self-documenting code** with clear intent
- **Use consistent formatting** and style
- **Remove unused code** and dependencies
- **Use proper imports** and exports

### Security Checklist:
- [ ] Input validation implemented
- [ ] Output encoding applied
- [ ] Authentication required where needed
- [ ] Authorization checks in place
- [ ] Sensitive data encrypted
- [ ] Error messages don't leak information
- [ ] Logging doesn't expose sensitive data
- [ ] HTTPS enforced
- [ ] CORS configured properly
- [ ] Rate limiting implemented

### Performance Checklist:
- [ ] Database queries optimized
- [ ] Caching implemented where appropriate
- [ ] Images optimized and lazy loaded
- [ ] Code splitting implemented
- [ ] Bundle size analyzed
- [ ] Loading states implemented
- [ ] Error boundaries in place
- [ ] Memory leaks prevented
- [ ] API response times acceptable
- [ ] CDN configured for static assets